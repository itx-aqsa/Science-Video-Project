from fastapi import FastAPI, HTTPException, UploadFile, File
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List
import uvicorn
import json
import time
from datetime import datetime

# Initialize FastAPI app
app = FastAPI(
    title="EduAI Pro API",
    description="AI-Powered Educational Content Generation API",
    version="1.0.0"
)

# Add CORS middleware for Next.js frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"],  # Next.js dev server
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Pydantic models for request/response
class ScriptGenerateRequest(BaseModel):
    topic: str
    duration: int
    audience_level: Optional[str] = "general"
    language: Optional[str] = "english"

class ScriptGenerateResponse(BaseModel):
    success: bool
    script: str
    word_count: int
    estimated_duration: str
    generated_at: str

class TranslateRequest(BaseModel):
    text: str
    target_language: str
    source_language: Optional[str] = "auto"

class TranslateResponse(BaseModel):
    success: bool
    translated_text: str
    source_language: str
    target_language: str
    confidence_score: float

class TextToSpeechRequest(BaseModel):
    text: str
    voice_type: Optional[str] = "female"
    speed: Optional[float] = 1.0
    pitch: Optional[int] = 0
    language: Optional[str] = "en"

class TextToSpeechResponse(BaseModel):
    success: bool
    audio_url: str
    duration: str
    file_size: str
    format: str

# Helper function to simulate AI script generation
def generate_educational_script(topic: str, duration: int, audience_level: str = "general") -> str:
    """
    Simulate AI script generation - Replace with your actual AI model
    """
    script_template = f"""
# Educational Script: {topic}

## Introduction
Welcome to today's lesson on {topic}. This {duration}-minute educational content is designed for {audience_level} learners.

## Main Content

### Key Concept 1: Understanding {topic}
{topic} is a fundamental concept that plays a crucial role in education. Let's explore the basic principles and understand why it matters.

### Key Concept 2: Practical Applications
Now that we understand the basics, let's look at how {topic} applies in real-world scenarios:

1. **Primary Application**: Direct implementation in educational settings
2. **Secondary Application**: Supporting role in related fields
3. **Advanced Application**: Integration with modern technology

### Key Concept 3: Examples and Case Studies
To better understand {topic}, let's examine some practical examples:

- **Example 1**: Basic implementation showing core principles
- **Example 2**: Intermediate application with real-world context
- **Example 3**: Advanced usage demonstrating full potential

## Summary and Key Takeaways

In this {duration}-minute session, we've covered:
- Fundamental concepts of {topic}
- Practical applications and use cases
- Real-world examples and implementations

## Conclusion
Understanding {topic} is essential for {audience_level} learners. The concepts we've discussed today provide a solid foundation for further exploration.

Remember to practice these concepts and apply them in your own learning journey.

---
*Generated by EduAI Pro - AI-Powered Educational Content*
"""
    return script_template.strip()

def simulate_translation(text: str, target_language: str, source_language: str = "auto") -> dict:
    """
    Simulate translation - Replace with your actual translation service
    """
    language_map = {
        "chinese-simplified": "ä¸­æ–‡ (ç®€ä½“)",
        "chinese-traditional": "ä¸­æ–‡ (ç¹é«”)",
        "spanish": "EspaÃ±ol",
        "french": "FranÃ§ais",
        "german": "Deutsch",
        "italian": "Italiano",
        "japanese": "æ—¥æœ¬èª",
        "turkish": "TÃ¼rkÃ§e",
        "russian": "Ğ ÑƒÑÑĞºĞ¸Ğ¹"
    }
    
    # Simulate translation (replace with actual translation logic)
    if target_language == "chinese-simplified":
        translated_text = f"[ä¸­æ–‡ç¿»è¯‘] {text[:100]}...\n\nè¿™æ˜¯ä¸€ä¸ªæ¨¡æ‹Ÿçš„ä¸­æ–‡ç¿»è¯‘ã€‚åœ¨å®é™…å®ç°ä¸­ï¼Œè¿™é‡Œä¼šæ˜¯çœŸæ­£çš„AIç¿»è¯‘ç»“æœã€‚"
    elif target_language == "spanish":
        translated_text = f"[TraducciÃ³n al EspaÃ±ol] {text[:100]}...\n\nEsta es una traducciÃ³n simulada al espaÃ±ol. En la implementaciÃ³n real, aquÃ­ estarÃ­a el resultado de traducciÃ³n de IA."
    else:
        translated_text = f"[Translated to {language_map.get(target_language, target_language)}] {text[:100]}...\n\nThis is a simulated translation. In actual implementation, this would be the real AI translation result."
    
    return {
        "translated_text": translated_text,
        "confidence_score": 0.95,
        "detected_language": "english" if source_language == "auto" else source_language
    }

# API Endpoints

@app.get("/")
async def root():
    return {
        "message": "EduAI Pro API is running!",
        "version": "1.0.0",
        "endpoints": [
            "/generate-script",
            "/generate-video-script", 
            "/translate-script",
            "/text-to-speech",
            "/health"
        ]
    }

@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "service": "EduAI Pro API"
    }

@app.post("/generate-script", response_model=ScriptGenerateResponse)
async def generate_script(request: ScriptGenerateRequest):
    """
    Generate educational script based on topic and duration
    """
    try:
        # Validate input
        if not request.topic.strip():
            raise HTTPException(status_code=400, detail="Topic cannot be empty")
        
        if request.duration < 1 or request.duration > 60:
            raise HTTPException(status_code=400, detail="Duration must be between 1 and 60 minutes")
        
        # Simulate processing time
        time.sleep(1)
        
        # Generate script using AI (replace with your actual implementation)
        script = generate_educational_script(
            topic=request.topic,
            duration=request.duration,
            audience_level=request.audience_level
        )
        
        # Calculate metrics
        word_count = len(script.split())
        estimated_duration = f"{request.duration} minutes"
        
        return ScriptGenerateResponse(
            success=True,
            script=script,
            word_count=word_count,
            estimated_duration=estimated_duration,
            generated_at=datetime.now().isoformat()
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Script generation failed: {str(e)}")

@app.post("/generate-video-script", response_model=ScriptGenerateResponse)
async def generate_video_script(request: ScriptGenerateRequest):
    """
    Generate video-optimized educational script
    """
    try:
        # Validate input
        if not request.topic.strip():
            raise HTTPException(status_code=400, detail="Topic cannot be empty")
        
        # Simulate processing time
        time.sleep(1.5)
        
        # Generate video-optimized script
        base_script = generate_educational_script(
            topic=request.topic,
            duration=request.duration,
            audience_level=request.audience_level
        )
        
        # Add video-specific formatting
        video_script = f"""
[VIDEO SCRIPT - OPTIMIZED FOR VISUAL CONTENT]

{base_script}

## Video Production Notes:
- **Opening Scene**: Show title card with topic name
- **Transition Effects**: Use smooth transitions between sections
- **Visual Aids**: Include relevant images, charts, or animations
- **Closing Scene**: Summary slide with key takeaways

## Timing Guidelines:
- Introduction: 10% of total duration
- Main Content: 70% of total duration  
- Summary: 15% of total duration
- Closing: 5% of total duration

[END VIDEO SCRIPT]
"""
        
        word_count = len(video_script.split())
        
        return ScriptGenerateResponse(
            success=True,
            script=video_script,
            word_count=word_count,
            estimated_duration=f"{request.duration} minutes (video format)",
            generated_at=datetime.now().isoformat()
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Video script generation failed: {str(e)}")

@app.post("/translate-script", response_model=TranslateResponse)
async def translate_script(request: TranslateRequest):
    """
    Translate script to target language
    """
    try:
        # Validate input
        if not request.text.strip():
            raise HTTPException(status_code=400, detail="Text cannot be empty")
        
        if not request.target_language:
            raise HTTPException(status_code=400, detail="Target language is required")
        
        # Simulate processing time
        time.sleep(2)
        
        # Perform translation (replace with your actual translation service)
        translation_result = simulate_translation(
            text=request.text,
            target_language=request.target_language,
            source_language=request.source_language
        )
        
        return TranslateResponse(
            success=True,
            translated_text=translation_result["translated_text"],
            source_language=translation_result["detected_language"],
            target_language=request.target_language,
            confidence_score=translation_result["confidence_score"]
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Translation failed: {str(e)}")

@app.post("/text-to-speech", response_model=TextToSpeechResponse)
async def text_to_speech(request: TextToSpeechRequest):
    """
    Convert text to speech audio
    """
    try:
        # Validate input
        if not request.text.strip():
            raise HTTPException(status_code=400, detail="Text cannot be empty")
        
        # Simulate processing time
        time.sleep(3)
        
        # Simulate TTS processing (replace with your actual TTS service)
        word_count = len(request.text.split())
        estimated_duration_seconds = int(word_count / 2.5 * request.speed)  # Average speaking rate
        duration_minutes = estimated_duration_seconds // 60
        duration_seconds = estimated_duration_seconds % 60
        
        # Simulate audio file creation
        audio_filename = f"audio_{int(time.time())}.mp3"
        audio_url = f"/audio/{audio_filename}"
        file_size = f"{word_count * 0.1:.1f} MB"  # Rough estimate
        
        return TextToSpeechResponse(
            success=True,
            audio_url=audio_url,
            duration=f"{duration_minutes}:{duration_seconds:02d}",
            file_size=file_size,
            format="MP3"
        )
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Text-to-speech conversion failed: {str(e)}")

@app.post("/upload-document")
async def upload_document(file: UploadFile = File(...)):
    """
    Upload and process document for text-to-speech
    """
    try:
        # Validate file type
        allowed_types = ["text/plain", "application/pdf", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"]
        if file.content_type not in allowed_types:
            raise HTTPException(status_code=400, detail="Unsupported file type")
        
        # Validate file size (10MB limit)
        file_size = 0
        content = await file.read()
        file_size = len(content)
        
        if file_size > 10 * 1024 * 1024:  # 10MB
            raise HTTPException(status_code=400, detail="File size too large (max 10MB)")
        
        # Simulate document processing
        time.sleep(2)
        
        # Extract text (replace with actual document processing)
        if file.content_type == "text/plain":
            extracted_text = content.decode("utf-8")
        else:
            # Simulate text extraction for PDF/DOCX
            extracted_text = f"Extracted text from {file.filename}:\n\nThis is simulated extracted text. In actual implementation, this would be the real extracted content from the uploaded document."
        
        # Detect language (simulate)
        detected_language = "English"
        confidence_score = 0.95
        word_count = len(extracted_text.split())
        
        return {
            "success": True,
            "filename": file.filename,
            "file_size": f"{file_size / 1024:.1f} KB",
            "detected_language": detected_language,
            "confidence_score": confidence_score,
            "word_count": word_count,
            "estimated_audio_duration": f"{word_count // 150} minutes",
            "extracted_text": extracted_text[:500] + "..." if len(extracted_text) > 500 else extracted_text
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Document upload failed: {str(e)}")

# Run the server
if __name__ == "__main__":
    print("ğŸš€ Starting EduAI Pro FastAPI Server...")
    print("ğŸ“ Server will be available at: http://localhost:8000")
    print("ğŸ“– API Documentation: http://localhost:8000/docs")
    print("ğŸ”§ Interactive API: http://localhost:8000/redoc")
    
    uvicorn.run(
        "fastapi-backend:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info"
    )
